{"componentChunkName":"component---src-components-templates-post-template-tsx","path":"/ko/post/logic-for-programmers-000/","result":{"data":{"post":{"frontmatter":{"title":"프로그래머를 위한 논리학 - 0","date":"6 days ago"},"html":"<h1 id=\"들어가며\" style=\"position:relative;\"><a href=\"#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\" aria-label=\"들어가며 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>들어가며</h1>\n<p>개발자 생활을 하다보면 한 번쯤 듣게 되는 (혹은 보게 되는) 말이 있다. 바로</p>\n<blockquote>\n<p>좋은 개발자가 되려면 수학(혹은 논리학)을 배워야지!</p>\n</blockquote>\n<p>이다. 물론 필자가 이런 주장에 완전히 동의한다는 말은 아니다. 그러나 누군가 위 주장을 아래와 같이 조금 수정한다면, 필자는 언제 어디서든지 옹호할 생각이 있다.</p>\n<blockquote>\n<p>함수형 개발을 잘 하는 개발자가 되려면 수학(혹은 논리학)을 배워야지!</p>\n</blockquote>\n<p>좀 더 나아가서 필자가 좌우명으로 삼고 싶을 정도로 바꿀 수도 있다.</p>\n<blockquote>\n<p>강한 자료형 언어로 개발을 잘 하려면 수학<strong>과</strong> 논리학을 배워야지!</p>\n</blockquote>\n<p>그렇다. 필자는 강한 자료형 언어를 사용하는 개발자는 개발을 배우기 전이던 배운 후던 간에 적어도 언젠가는 수학과 논리학을 배워야한다고 생각한다. 특히 그 언어를 잘 하고 싶다는 생각을 가지고 있다면 더더욱 그래야한다고 생각한다.</p>\n<p>이는 그런 언어의 고급 개념들이 수학 혹은 논리학에서 비롯했거나 십분 이용하고 있다는 점에 근거한다. 그런 언어들이 기반하고 있는 자료형 이론자체가 수학에서 비롯되었다는 사실이 그 예시이다. OCaml의 함자(Functor)와 Haskell의 (악명높은) 모나드(Monad) 또한 수학에 이미 존재하는 개념으로부터 그 이름을 따왔을 뿐 아니라 원래 개념과 깊은 관련성을 가지고 있다는 점 역시 빼놓을 수 없으며, C++/Java 사용자가 익숙할 템플릿(Template)/제네릭(Generics)도 수학의 다형 람다 대수(Polymorphic lambda calculus)에 그 뿌리를 두고 있다는 것 또한 특기할만 하다. 이런 복잡한 개념뿐만이 아니라 비교적 간단하고 널리 사용되는 개념들 또한 수학 혹은 논리학에서 유래했거나 깊히 관련된 것이 많은데, 부울 대수(Bool algebra)라던가 재귀(Recursion), 변수의 유효범위(Scope)가 그런 예시들이다.</p>\n<p>이런 개념의 연관성을 떠나서 좀 더 실용적인 측면에서도 수학과 논리학은 개발에 영향을 미치고 있다. 유명한 C 컴파일러(Compiler) 중 하나인 GCC의 수십 개의 버그(Bug)를 수학과 콕(Coq)이라는 증명 보조도구를 사용해 잡아내는가하면, Java의 병렬 메모리 모델(Parallel memory model)이 가지고 있는 문제점을 고쳐 병렬 개발에 대한 이해 방식을 개선하는데에 도움을 주기도 했다.</p>\n<p>이렇듯 수학과 논리학은 개발자에게 (적어도 강한 자료형 언어를 사용하는 개발자에게는) 더 깊은 이해와 개발에 대한 통찰을 제공한다. 그러나 안타까운 사실은 국어로 수학과 논리학을, 특히 강한 자료형을 사용하는 프로그래머에게 필요한 수학과 논리학을 배우는게 쉬운 일이 아니라는 점이다. 무엇보다 국어로 된 자료의 절대 수가 부족한 환경이 제일의 문제이다. 더불어, 그나마 있는 자료들도 질이 떨어지거나 업데이트가 이루어지지 않는 등 자잘한 문제들이 있는 경우가 태반이다. 이런 상황에서 배우려는 내용 자체의 난이도와는 별개로, 배우는 과정 자체가 편할 리가 만무하다.</p>\n<p>이 글은 이러한 현실을 조금이라도 개선하고자하는 의지를 담아 쓰였다. 이 글과 이어지는 글들도 같은 정신을 이어 써 나갈 것이다. 이 글을 통해, 그리고 이 글을 읽은 독자 여러분이 앞으로 써 나아갈 글과 말을 통해 국어로 수학과 논리학을 배우는 것이 좀 더 쉬워지기를 바라며 서두를 마치도록 하겠다.</p>\n<h1 id=\"논리학을-시작하기-전에\" style=\"position:relative;\"><a href=\"#%EB%85%BC%EB%A6%AC%ED%95%99%EC%9D%84-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EC%A0%84%EC%97%90\" aria-label=\"논리학을 시작하기 전에 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>논리학을 시작하기 전에</h1>\n<p>이 장에서는 논리학을 위해 필요한 간단한 개념들을 다루어 볼 것이다. 사용(Using)과 언급(Mentioning), 그리고 명제와 논증에 대해서 소개하고, 어떻게 그 개념들이 논리학에 등장하는지 간단한 예시를 들어 설명할 것이다.</p>\n<h2 id=\"헷갈리기-쉬운-것을-구분하자--사용과-언급\" style=\"position:relative;\"><a href=\"#%ED%97%B7%EA%B0%88%EB%A6%AC%EA%B8%B0-%EC%89%AC%EC%9A%B4-%EA%B2%83%EC%9D%84-%EA%B5%AC%EB%B6%84%ED%95%98%EC%9E%90--%EC%82%AC%EC%9A%A9%EA%B3%BC-%EC%96%B8%EA%B8%89\" aria-label=\"헷갈리기 쉬운 것을 구분하자  사용과 언급 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>헷갈리기 쉬운 것을 구분하자! : 사용과 언급</h2>\n<p>개념의 <strong>사용</strong>(Using)과 개념의 <strong>언급</strong>(Mentioning)은 굉장히 자주 헷갈리는 개념 중 하나지만, 논리학을 할 때에는 반드시 구분해야하는 개념이다. 이 장부터 시작하여 이 글과 이 글에 이어지는 글들에서는 모두 개념의 사용과 언급을 구분할 것이기 때문에, 이 둘이 어떻게 다른지, 그리고 왜 구분해야되는지에 대해서 이 장에서 설명하고 넘어가고자 한다.</p>\n<p>우선 일반적인 개념 대신 단어에 집중해서 둘을 구분해보도록 하자. 다음은 어떤 단어를 <strong>사용</strong>하는 경우의 예시이다.</p>\n<ul>\n<li>자연은 아름답다.</li>\n<li>1과 1을 더하면 2이다.</li>\n<li>적분은 어렵다.</li>\n</ul>\n<p>이어서, 어떤 단어를 <strong>언급</strong>하는 경우의 예시도 보도록 하자. 보통 <strong>언급</strong>된 단어는 작은 따옴표(')로 둘러싸 표시한다.</p>\n<ul>\n<li>'아름답다'는 네 글자로 이루어져 있다.</li>\n<li>'1'과 '1', '+'에 '='를 합치면 창문이 된다.</li>\n<li>'자연'은 두 음절로 읽힌다.</li>\n</ul>\n<p>대략적으로 어떤 차이인지 이해한 독자들도 있을 것이다. 좀 더 분명히 설명해보면 <strong>사용</strong>된 단어는 단어가 가리키는 것을 말하기 위해 사용하는 것이고, <strong>언급</strong>된 단어는 그 단어 자체를 말하기 위해서 사용된 것이다. C 나 C++ 등의 개발 언어에서 볼 수 있는 포인터(Pointer)와 비슷한 방식으로 이해할 수 있다. 단어를 단어의 의미를 가리키는 포인터 <code>p</code>로 생각하면, <strong>사용</strong>된 단어는 <code>*p</code>를 말하는 것이고, <strong>언급</strong>된 단어는 <code>p</code>라는 포인터 자체를 말하는 것이다. 다시 예를 들어</p>\n<ul>\n<li>그 책은 200 장의 종이로 만들어졌다.</li>\n</ul>\n<p>는 '책'이라고 불리는 종이 위에 글씨가 쓰여진 물체 중 하나의 구성이 어떻게 되어있는지 설명하고 있기 때문에 평범하게 말이 되는 문장이지만</p>\n<ul>\n<li>'그 책'은 200 장의 종이로 만들어졌다.</li>\n</ul>\n<p>는 '그 책'이라는 단어들이 200 장의 종이로 만들어졌다는 걸 의미하고, 단어들은 종이로 만들어진 것이 아니므로 이상한 문장이 된다. 다시</p>\n<ul>\n<li>그 책은 두 단어로 되어있다.</li>\n</ul>\n<p>는 단어가 두 개밖에 안 쓰여져 있는 무언가 이상한 책에 대한 이야기를 하는 문장이지만</p>\n<ul>\n<li>'그 책'은 두 단어로 되어있다.</li>\n</ul>\n<p>는 평범하게 '그 책'이라는 단어들이 단어 두 개로 구성되어있다는 이야기이니, 이상할 것 없이 맞는 문장이다.</p>\n<p>일반적인 개념의 경우에도 단어와 비슷한 방식으로 이해할 수 있다. 물론 개념을 글로 설명하기 위해서는 항상 단어들이 필요하다는 문제 때문에 예시를 설명하기가 좀 더 난해해진다는 것은 어쩔 수 없는 난점이다. 다음의 예시를 보자.</p>\n<ul>\n<li>자연은 아름답다.</li>\n</ul>\n<p>에서 '자연'이라는 단어는 '자연'이 가리키는 개념(자연)을 <strong>언급</strong>하기 위해서 <strong>사용</strong>된 것이고,</p>\n<ul>\n<li>'자연'은 두 음절로 읽힌다.</li>\n</ul>\n<p>에서 ''자연''이라는 작은 따옴표로 둘러싸인 표현은 '자연'이라는 단어 자체를 <strong>언급</strong>하기 위해서 <strong>사용</strong>된 것이다.</p>\n<p>논리학에서 명제를 분석하기 위해서는 이 둘을 구분하는 것이 필수적이다. P와 'P'를 구분하지 못하면 다음과 같은 설명을 올바르게 이해할 수 없기 때문이다.</p>\n<ul>\n<li>P는 참이다.</li>\n<li>'→'는 조건문을 쓰기 위한 기호다.</li>\n<li>P ∧ Q 는 P와 Q가 모두 참일 때에만 참이다.</li>\n<li>'P ∨ Q'는 P와 Q 중 하나 이상이 참일 때에만 참인 명제를 쓰는 방법이다.</li>\n<li>\n<p>P가 참이라면 MP 법칙에 의해 Q도 참이다.</p>\n<!-- 이 말 안에서 사용/언급을 제대로 구분했는지 재확인 -->\n</li>\n<li>MP 법칙은 'P ⊢ P → Q' 꼴의 명제로부터 'P ⊢ Q' 꼴의 명제를 유도하는 법칙이다.</li>\n</ul>\n<h2 id=\"사용언급-연습문제\" style=\"position:relative;\"><a href=\"#%EC%82%AC%EC%9A%A9%EC%96%B8%EA%B8%89-%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C\" aria-label=\"사용언급 연습문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>사용/언급 연습문제</h2>\n<details>\n  <summary>\n<p>'1은 수이다.'라는 문장은 '1'을 올바르게 <strong>사용</strong>하고 있을까?</p>\n  </summary>\n<p>올바르게 사용하고 있다. 위 문장에서 '1'이라는 표현은 1이라는 수를 가리키기 위해서 <strong>사용</strong>되었다.</p>\n</details>\n<details>\n  <summary>\n<p>''1'은 수이다.'라는 문장은 ''1''을 올바르게 <strong>사용</strong>하고 있을까?</p>\n  </summary>\n<p>올바르지 않게 사용하고 있다. 위 문장에서 ''1''이라는 표현은 단어 '1'을 가리키기 위해서 <strong>사용</strong>되었다. 문장 안에서 <strong>언급</strong>된 '1'은 수가 아니고 수를 쓰기 위해서 <strong>사용</strong>하는 숫자(혹은 글자)이다.</p>\n</details>\n<details>\n  <summary>\n<p>다음 문장에서, 사용/언급이 구분되지 않은 단어인 '베토벤'은 <strong>사용</strong>되고 있는 것일까 아니면 <strong>언급</strong>되고 있는 것일까? 그리고 올바르게 구분하여 표기하려면 어떻게 표기해야할까?</p>\n<p>'베토벤은 운명 교향곡을 작곡한 사람의 이름이다.'</p>\n  </summary>\n<p>올바른 표기는 ''베토벤'은 운명교향곡을 작곡한 사람의 이름이다.'이고, 여기서 '베토벤'은 작곡가 베토벤의 한글로 적힌 이름 '베토벤'을 <strong>언급</strong>하는 단어이다.</p>\n</details>\n<h2 id=\"논리학은-무엇을-다루는-것일까--명제\" style=\"position:relative;\"><a href=\"#%EB%85%BC%EB%A6%AC%ED%95%99%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%84-%EB%8B%A4%EB%A3%A8%EB%8A%94-%EA%B2%83%EC%9D%BC%EA%B9%8C--%EB%AA%85%EC%A0%9C\" aria-label=\"논리학은 무엇을 다루는 것일까  명제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>논리학은 무엇을 다루는 것일까? : 명제</h2>\n<p>모든 학문은 특정한 대상을 다루고 있다. 경제학은 각종 재화의 흐름과 그 흐름을 예측할 이론들을 대상으로 삼는다. 물리학은 물리적으로 존재하는 물질들이 어떻게 상호작용하는지를 대상으로 삼는다. 컴퓨터 공학은 컴퓨터의 구조와 프로그램의 구조를 그 대상으로 삼는다. 그렇다면 논리학이 다루는 대상은 무엇일까? 바로 명제와 명제를 증명하는 논증이다. 이 장에서는 명제가 무엇인지 다루고, 이후 세부적인 논리학들에 대해 다루면서 논증이 어떻게 이루어지는지에 대해서 이야기 할 것이다.</p>\n<p>명제란 무엇인가? 명제는 논리학의 긴 역사만큼 다양한 정의를 가지고 있기 때문에 한마디로 답하기 쉽지 않은 질문이다. 이 장에서는 명제의 정의를 오래된 것부터 차례대로 살펴보고 어떤 정의를 기준으로 논의를 이어나갈지 이야기해보도록 할 것이다.</p>\n<p>논리학을 이론화시키기 시작한 사람 중 하나인 아리스토텔레스(Aristotle)는 '명제란 자연에서부터 얻어진 것과 그것을 설명하는 서술어의 조합으로 이루어져 있고, 그 조합이 옳거나 틀렸다는 것을 보여주는 문장'이라고 생각했다. 아리스토텔레스의 정의에 따르면 다음과 같은 문장들이 명제이다.</p>\n<ul>\n<li>소크라테스는 사람이다.</li>\n<li>모든 사람은 언젠가 죽는다.</li>\n</ul>\n<p>첫번째 문장의 주어(자연으로부터 얻어진 것)는 '소크라테스'이고, 서술어는 '사람이다'이다. 두번째 문장의 주어는 '사람'이고, 서술어는 '언젠가 죽는다'이다. 이 두 문장은 주어와 서술어의 조합이 옳다는 것을 보여주고 있다. 반면에,</p>\n<ul>\n<li>모든 버섯은 곤충이 아니다.</li>\n<li>지구는 직육면체가 아니다.</li>\n<li>어떤 의자는 다리가 두 개가 아니다.</li>\n</ul>\n<p>같은 문장을 보면, 첫번째 문장의 주어는 '버섯', 서술어는 '곤충이다'이지만, '모든'과 '아니다'를 통해 주어와 서술어의 조합이 항상 틀렸다는 것을 보여주고 있다. 마찬가지로 두번째 문장은 '지구'와 '직육면체이다'의 조합이지만, '아니다'를 통해 이 조합이 틀렸다는 것을 보여주고 있으며, 세번째 문장은 '의자'와 '다리가 두 개이다'의 조합이 조건에 따라 틀렸다는 것을 '어떤'과 '아니다'를 사용해 보여주고 있다. 위 문장들에서 '모든'과 '어떤'이 등장하는데, 이 역시 아리스토텔레스의 명제에 대한 설명에 포함되어있기 때문이다. 아리스토텔레스는 보통 명사('나무', '숲', '사과' 등)에 대해서는 '모든'/'어떤'을 사용해 주어를 꾸미는 것이 가능하다고 주장했고, 반면에 고유명사('안창호', '아리스토텔레스', '소크라테스')에 대해서는 이런 꾸밈이 불가능하다고 주장했다. 따라서 다음과 같은 문장은 잘못된 명제이다.</p>\n<ul>\n<li>모든 소크라테스는 사람이다.</li>\n<li>어떤 베토벤은 죽었다.</li>\n</ul>\n<p>지금까지의 정의는 아리스토텔레스가 설명하려고 했던 삼단논법(Syllogism)과 간단한 논증을 어느정도 설명할 수 있었지만, 바로 위에서 설명한 문장을 포함하여 다음과 같은 문장도 명제를 통해 설명할 수 없다는 문제를 가지고 있었다.\n.</p>\n<ul>\n<li>햄릿은 왕자이다</li>\n<li>경제학은 재화의 흐름을 다루는 학문이다.</li>\n<li>소크라테스가 사람이면 소크라테스는 언젠가 죽는다.</li>\n<li>모든 고양이는 어떤 쥐를 잡아먹는다.</li>\n</ul>\n<p>첫번째 문장은 주어('햄릿')이 존재하지 않기 때문에 명제가 아니다. 두번째 문장은 주어('경제학')가 자연으로부터 얻어진 것이 아니기 때문에 명제가 아니다. 세번째 문장은 '이면'이라는 조건문을 구성하는 연산자를 사용했는데, 아리스토텔레스의 명제는 이러한 연산문들을 다루지 않았기 때문에 명제가 아니다. 네번째 문장은 문장 자체는 '고양이'를 주어로 삼고 '어떤 쥐를 잡아먹는다'를 서술어로 삼는 명제가 맞으나, 이 문장의 서술어와 이 문장의 부정인 '어떤 고양이는 모든 쥐를 잡아먹지 못한다'의 서술어인 '모든 쥐를 잡아먹지 못한다' 사이의 관계를 아리스토텔레스의 방식으로는 설명할 수 없다. ('어떤 쥐를 잡아먹는다'와 '모든 쥐를 잡아먹지 못한다'가 각각 독립적인 하나의 서술어이고, '쥐를 잡아먹는다'와 '모든'/'어떤'의 조합이 아니기 때문이다.)</p>\n<p>아리스토텔레스와 함께 그 시대의 논리학을 대표하는 두 파벌 중 하나인 스토아 학파(Stoicism)는 간단한 주장대상(assertible)을</p>\n<ul>\n<li>의미를 가진 발화(utterance)이고</li>\n<li>(배중률, law of excluded middle) 꼭 참이나 거짓 둘 중 하나로 평가될 수 있으며</li>\n<li>(모순률, law of noncontradiction) 참이나 거짓 둘 중 하나로만 평가되는</li>\n</ul>\n<p>것으로 정의했다. 또는 복잡한 주장대상을 간단한 주장대상과 논리 연산자를 사용해서 얻어낼 수 있는 것들로 정의했다. 이 주장대상의 정의는 현대적인 명제의 정의와 비슷하고, 이후의 논리학 발전에 큰 영향을 미쳤다. 그러나 이들의 정의는 주장대상의 범위를 엄밀하게 정해놓지 않았기 때문에 아래와 같은 역설적인 문장들을 만들어낼 수 있다는 문제를 가지고 있다.</p>\n<ul>\n<li>이 주장대상은 거짓이다.</li>\n<li>자신은 거짓말만을 말한다는 남자가 있다면 그 남자의 말은 거짓이다.</li>\n</ul>\n<p>이러한 역설은 이후 러셀(Russell)을 통해 해결된다.</p>\n<p>그리스 시대 이후로 논리학은 크게 발전하지는 못했는데, 이는 그리스 시대를 포함한 중세 동안 논리학이 학문으로서보다도 철학에 필요한 부속품 정도로 여겨졌고, 논리학적인 역설을 해결하기보다 논리적인 사고를 통해 철학의 문제들을 해결하는데에 더 집중하였기 때문이다. 논리학이 다시금 조명을 받게 되는 것은 근대의 수학자들에 의해서인데, 그 중 대표적인 두 사람이 고틀롭 프레게(Gottlob Frege)와 버트런드 러셀(Bertrand Russell)이다.</p>\n<p>프레게는 개념의 <strong>뜻</strong>(Meaning)과 <strong>지시체</strong>(Reference)를 구분한 뒤, 명제를 말이 되는 문장의 <strong>뜻</strong>으로 정의했다. 이를 이해하기 위해서는 개념의 <strong>뜻</strong>과 <strong>지시체</strong>에 대해서 간단히 설명해야할 것이다. <strong>지시체</strong>란 개념이 가리키는 대상을 말한다. 예를 들어 '태양'이라는 단어는 '태양'이라고 이름붙은 별을 가리키고 있으므로, '태양'이라는 단어의 <strong>지시체</strong>는 (지구가 돌고 있는 별인) 태양이다. 여러 개념들이 동일한 <strong>지시체</strong>를 가질 수 있다. 예를 들면</p>\n<ul>\n<li>운명 교향곡의 작곡자</li>\n<li>베토벤</li>\n</ul>\n<p>의 두 표현은 동일한 <strong>지시체</strong>를 가진다. 반면, <strong>뜻</strong>이란 개념이 <strong>지시체</strong>를 가리키는 <strong>방식</strong>을 말한다. 앞서 말한 '운명 교향곡의 작곡자'라는 표현은 베토벤을 <strong>지시</strong>하기 위해 운명 교향곡을 언급하고 있으며, 운명 교향곡이 누구에게 작곡되었는지 모르고 있는 사람도 <strong>지시체</strong>가 어떤 일을 했는지 이해할 수 있는 표현이다. 반면에, '베토벤'이라는 표현은 베토벤을 <strong>지시</strong>하기 위해 본인의 이름 외에 어떤 다른 개념도 언급하고 있지 않으며, '베토벤'이라고 이름붙은 사람이 어떤 이인지 모르는 사람에게 그 <strong>지시체</strong>가 무슨 일을 했는지 어떤 정보도 주지 않는다. 개념의 <strong>뜻</strong>이 <strong>지시체</strong>를 가리키는 방식이라면, 말이 되는 문장의 <strong>뜻</strong>, 즉 명제가 어떻게 정의된 것인지 이해하기 위해서는 말이 되는 문장의 <strong>지시체</strong>가 무엇인지 알아야 할 것이다. 프레게는 이 <strong>지시체</strong>가 진리치라고 주장했다. 다시 말해서 프레게는 '명제는 문장이 진리치를 가리키는 방식이다'라고 명제를 정의했다는 것이다. 다음의 예시를 보자.</p>\n<ul>\n<li>지구는 태양을 중심으로 돈다.</li>\n</ul>\n<p>는 참이므로, 이 문장의 <strong>지시체</strong>는 참이라는 진리치이다. 이 문장은 '지구는 태양을 중심으로 돈다'라는 표현을 사용해서 이 진리치를 가리키고 있고, 이것은 '1 + 1 = 2'나 '우주는 우주이다'와는 그 진리치(참)를 가리키고 있는 방식이 다르다.</p>\n<p>이 부분이 약간 난해할 수 있기에, 개발자들의 이해를 돕기 위해 개발할 때 사용하는 함수로 비유를 해보겠다. 피보나치 수열(Fibonacci sequence)의 5 번째 항을 계산하는 함수를 만든다고 해보자. 계산 결과 값은 함수를 어떻게 만들든 (올바르게만 만들었다면) 다 똑같을테지만, 계산에 걸리는 시간, 메모리, 구현의 가독성 등 여러가지 측면이 다른 함수들을 만들 수 있을 것이다. 여기서 피보나치 수열의 5 번째 항을 <strong>지시체</strong>(계산된/가리키는 것)라고 생각하면, 함수들이 구현된 방식이 바로 <strong>뜻</strong>(계산하는/가리키는 방식)이다.</p>\n<p>러셀은 프레게의 이런 구분을 비판하면서 문장의 <strong>지시체</strong>가 진리치일 필요가 없고, 그렇기 때문에 명제를 설명하기 위해 <strong>뜻</strong> 같은 혼란스러운 개념을 도입할 필요가 없다고 주장했다. 러셀은 문장의 <strong>지시체</strong>가 바로 명제라고 정의했으며, 문장이 단어를 모아서 만들어지는 것처럼 명제도 단어의 <strong>지시체</strong>들을 모아서 만들어진다고 설명했다. 러셀의 입장에서 다음 문장</p>\n<ul>\n<li>지구는 태양을 중심으로 돈다.</li>\n</ul>\n<p>는 '지구는 태양을 중심으로 돈다'는 표현을 통해 지구가 태양을 중심으로 돈다는 명제를 <strong>지시</strong>하고 있는 것이고, 이 명제는 '지구'라는 단어의 <strong>지시체</strong>인 지구, '태양'이라는 단어의 <strong>지시체</strong>인 태양, '중심'라는 단어의 <strong>지시체</strong>인 중심, '돈다'라는 단어의 <strong>지시체</strong>인 돈다 등으로 구성되어 있는 것이다.</p>\n<p>이후의 논의는 러셀의 정의를 기준으로 삼을 것이다. 이는 러셀의 정의를 사용하면 철학적으로 복잡한 개념을 소개할 필요가 없고, 논리학의 문제에 집중하기 더 용이하기 때문이다.</p>","id":"9985c2e8-918a-5d53-99db-c5f985f57ef9","excerpt":"들어가며 개발자 생활을 하다보면 한 번쯤 듣게 되는 (혹은 보게 되는) 말이 있다. 바로 좋은 개발자가 되려면 수학(혹은 논리학)을 배워야지! 이다. 물론 필자가 이런 주장에 완…","postPath":"/ko/post/logic-for-programmers-000/","parent":{"__typename":"File","date":"5 days ago"}}},"pageContext":{"id":"9985c2e8-918a-5d53-99db-c5f985f57ef9"}}}